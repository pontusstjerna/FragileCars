package se.nocroft.model.drivers

import se.nocroft.model.cars.FragileCar
import se.nocroft.model.drivers.util.BotPoint
import se.nocroft.util.CfgParser
import se.nocroft.util.Geom.getPI
import java.awt.Color
import java.awt.Graphics2D
import java.awt.Point
import kotlin.math.PI
import kotlin.math.absoluteValue
import kotlin.math.atan2

class HugBotV2(car: FragileCar, trackName: String?) : Driver(car, trackName) {

    private var lastX: Int = car.middleX.toInt() ?: 0
    private var lastY: Int = car.middleY.toInt() ?: 0
    private var closestPoints: List<BotPoint> = emptyList()
    private var passedFirst = false

    private val initialHeading: Double = car.heading
    private val crashPoints = mutableListOf<BotPoint>()
    private val debugMode = CfgParser(CfgParser.STD_PATH).readBoolean("debugEnabled")

    override fun update(deltaTime: Double) {

        if (car.acceleration < 200) {
            car.accelerate()
        } else {
            car.brake()
        }

        closestPoints = closestTwoWallPoints()
        when {
            closestPoints.isEmpty() -> {
                findWall(deltaTime)
            }
            closestPoints.first().let {  it.distance(car.middleX, car.middleY) > it.radius } -> {
                findWall(deltaTime)
            }
            else -> {
                hugWall(closestPoints.first(), deltaTime)
                passedFirst = true
            }
        }

        detectCrash()
        lastX = car.middleX.toInt()
        lastY = car.middleY.toInt()
    }

    override fun paint(g: Graphics2D, scale: Double, scaleX: Int) {
        if (debugMode) {
            g.color = when (car.name.split(" ").first()) {
                "BLUE" -> Color.decode("#78A2CC")
                "RED" -> Color.RED
                "GREEN" -> Color.decode("#80C904")
                else -> Color.YELLOW
            }
            for (p in crashPoints) {
                val prevColor = g.color
                if (closestPoints.contains(p)) {
                    g.color = Color.ORANGE
                }

                val s = (scale * 10).toInt()
                g.fillRoundRect((p.x * scale).toInt() - s / 2 + scaleX, (p.y * scale).toInt() - s / 2, s, s, s, s)

                val dist = (scale * p.radius * 2).toInt()
                g.drawRoundRect((p.x * scale).toInt() - dist / 2 + scaleX, (p.y * scale).toInt() - dist / 2, dist, dist,
                        dist, dist)

                if (closestPoints.contains(p)) {
                    g.color = prevColor
                }
            }
        }
    }

    private fun closestTwoWallPoints(): List<BotPoint> {
        val closest = crashPoints.filter {
            it.distance(car.middleX, car.middleY) < it.radius
        }.lastOrNull()

        val closestIndex = crashPoints.indexOf(closest)
        val prev = crashPoints.getOrNull(closestIndex + 1)

        return listOfNotNull(closest, prev)
    }

    private fun findWall(deltaTime: Double) {
        if ((car.heading - initialHeading).absoluteValue < PI / 2 || passedFirst) {
            car.turnRight(deltaTime)
        }
    }

    private fun hugWall(point: BotPoint, deltaTime: Double) {
        val distanceToPoint = point.distance(car.middleX, car.middleY)
        val targetDistance = point.radius * 0.5
        car.turnLeft(deltaTime)
        if (distanceToPoint < targetDistance) {
            car.turnLeft(deltaTime)
        } else {
            car.turnRight(deltaTime)
        }
    }

    private fun headingToPoint(point: BotPoint): Double {
        return getPI(atan2(car.middleY - point.y, car.middleX - point.x) - (PI / 2) - getPI(car.heading))
    }

    private fun detectCrash() {
        val middleX = car.middleX
        val middleY = car.middleY

        if (Point.distance(middleX, middleY, lastX.toDouble(), lastY.toDouble()) > 100) {
            crashPoints.add(BotPoint(lastX, lastY, car.width.toDouble() * (if (crashPoints.isEmpty()) 0.8 else 0.6)))
            passedFirst = false
        }
    }
}